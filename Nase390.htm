<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>(Optional) The Yoneda lemma</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="Napkin.css" /> 
<meta name="src" content="Napkin.tex" /> 
</head><body 
>
  <!--l. 495--><div class="crosslinks"><p class="noindent">[<a 
href="Nase417.htm" >next</a>] [<a 
href="Nase389.htm" >prev</a>] [<a 
href="Nase389.htm#tailNase389.htm" >prev-tail</a>] [<a 
href="Nase366.htm#tailNase390.htm">tail</a>] [<a 
href="Nach69.htm#Nach70.htm" >up</a>] </p></div>
  <h3 class="sectionHead"><span class="titlemark">61.6</span>Â Â <a 
 id="x546-52300061.6"></a>(Optional) The Yoneda lemma</h3>
<!--l. 496--><p class="noindent" >Now that I have natural transformations, I can define: <a 
 id="x546-523001r1590"></a>
</p>
  <div class="newtheorem">
<!--l. 498--><p class="noindent" ><span class="head">
<a 
 id="x546-523002r1"></a>
<tspan font-family="cmbx" font-size="10">Definition 61.6.1.</tspan>  </span><a 
 id="x546-523003"></a>The <tspan font-family="cmbx" font-size="10">functor category</tspan> of two categories <tspan font-family="cmsy" font-size="10">ğ’œ </tspan>and <tspan font-family="cmsy" font-size="10">â„¬</tspan>, denoted [<tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmsy" font-size="10">â„¬</tspan>], is
defined as follows: </p>
     <ul class="itemize1">
     <li class="itemize">The objects of [<tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmsy" font-size="10">â„¬</tspan>] are (covariant) functors <tspan font-family="cmmi" font-size="10">F </tspan>: <tspan font-family="cmsy" font-size="10">ğ’œâ†’â„¬</tspan>, and
     </li>
     <li class="itemize">The morphisms are natural transformations <tspan font-family="cmmi" font-size="10">Î± </tspan>: <tspan font-family="cmmi" font-size="10">F </tspan><tspan font-family="cmsy" font-size="10">â†’ </tspan><tspan font-family="cmmi" font-size="10">G</tspan>.</li></ul>
  </div>
<!--l. 504--><p class="indent" >
</p>
<div class="mdframed" id="mdframed-1054">
<a 
 id="x546-523004r1591"></a>
<div class="newtheorem">
<!--l. 506--><p class="noindent" ><span class="head">
<a 
 id="x546-523005r2"></a>
<tspan font-family="cmbx" font-size="10">Question 61.6.2.</tspan>  </span><a 
 id="x546-523006"></a><tspan font-family="cmr" font-size="10">When are two objects in the functor category isomorphic?</tspan></p>
  </div>
<!--l. 507--><p class="indent" >  </p></div>
<!--l. 509--><p class="indent" >  With this, I can make good on the last example I mentioned at the beginning:</p>
<div class="mdframed" id="mdframed-1055">
<a 
 id="x546-523007r1592"></a>
<div class="newtheorem">
<!--l. 511--><p class="noindent" ><span class="head">
<a 
 id="x546-523008r3"></a>
<tspan font-family="cmbx" font-size="10">Exercise 61.6.3.</tspan>  </span><a 
 id="x546-523009"></a><tspan font-family="cmr" font-size="10">Construct the following functors:</tspan> </p>
                                                                                
                                                                                
     <ul class="itemize1">
     <li class="itemize"><tspan font-family="cmsy" font-size="10">ğ’œâ†’ </tspan><tspan font-family="cmr" font-size="10">[</tspan><tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmr" font-size="7">op</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmss" font-size="10">Set</tspan><tspan font-family="cmr" font-size="10">] by </tspan><tspan font-family="cmmi" font-size="10">A</tspan><img 
src="Na3041x.png" alt="â†¦â†’"  class="mapsto"  /><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="7">A</tspan></sub><tspan font-family="cmr" font-size="10">, which we call </tspan><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmsy" font-size="7">âˆ™</tspan></sub><tspan font-family="cmr" font-size="10">.</tspan>
     </li>
     <li class="itemize"><tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmr" font-size="7">op</tspan> <tspan font-family="cmsy" font-size="10">â†’ </tspan><tspan font-family="cmr" font-size="10">[</tspan><tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmss" font-size="10">Set</tspan><tspan font-family="cmr" font-size="10">] by </tspan><tspan font-family="cmmi" font-size="10">A</tspan><img 
src="Na3042x.png" alt="â†¦â†’"  class="mapsto"  /><tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmmi" font-size="7">A</tspan></sup><tspan font-family="cmr" font-size="10">, which we call </tspan><tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmsy" font-size="7">âˆ™</tspan></sup><tspan font-family="cmr" font-size="10">.</tspan></li></ul>
</p>
  </div>
<!--l. 516--><p class="indent" >  </p></div>
<!--l. 517--><p class="indent" >  Notice that we have opposite categories either way; even if you like <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmmi" font-size="8">A</tspan></sup> because it
is covariant, the map <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmsy" font-size="8">âˆ™</tspan></sup> is contravariant. So for what follows, weâ€™ll prefer to use
<tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmsy" font-size="8">âˆ™</tspan></sub>.
</p><!--l. 521--><p class="indent" >  The main observation now is that given a category <tspan font-family="cmsy" font-size="10">ğ’œ</tspan>, <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmsy" font-size="8">âˆ™</tspan></sub> provides some <tspan font-family="cmti" font-size="10">special </tspan>functors
<tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmr" font-size="8">op</tspan> <tspan font-family="cmsy" font-size="10">â†’</tspan><tspan font-family="cmss" font-size="10">Set</tspan> which are already â€œbuiltâ€ in to the category <tspan font-family="cmmi" font-size="10">A</tspan>. In light of this, we define:
<a 
 id="x546-523010r1593"></a>
</p>
  <div class="newtheorem">
<!--l. 525--><p class="noindent" ><span class="head">
<a 
 id="x546-523011r4"></a>
<tspan font-family="cmbx" font-size="10">Definition 61.6.4.</tspan>  </span><a 
 id="x546-523012"></a>A <tspan font-family="cmbx" font-size="10">presheaf</tspan> <tspan font-family="cmmi" font-size="10">X </tspan>is just a contravariant functor <tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmr" font-size="8">op</tspan> <tspan font-family="cmsy" font-size="10">â†’</tspan><tspan font-family="cmss" font-size="10">Set</tspan>. It is called
<tspan font-family="cmbx" font-size="10">representable</tspan> if <tspan font-family="cmmi" font-size="10">X</tspan><img 
src="Na3043x.png" alt="âˆ¼
="  class="cong"  /><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub> for some <tspan font-family="cmmi" font-size="10">A</tspan>.
</p>
  </div>
<!--l. 527--><p class="indent" >
In other words, when we think about representable, the question weâ€™re asking is:
     </p><blockquote class="quote">
     <!--l. 531--><p class="noindent" ><tspan font-family="cmti" font-size="10">What kind of presheaves are already â€œbuilt inâ€ to the category </tspan><tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmti" font-size="10">?</tspan></p></blockquote>
<!--l. 533--><p class="noindent" >One way to get at this question is: given a presheaf <tspan font-family="cmmi" font-size="10">X </tspan>and a particular <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>, we can look at the
<tspan font-family="cmti" font-size="10">set </tspan>of natural transformations <tspan font-family="cmmi" font-size="10">Î± </tspan>: <tspan font-family="cmmi" font-size="10">X</tspan> <img 
src="Na3044x.png" alt="= â‡’"  class="Longrightarrow"  /> <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>, and see if we can learn anything about it. In
fact, this set can be written explicitly:</p>
<div class="mdframed" id="mdframed-1056">
<a 
 id="x546-523013r1594"></a>
<div class="newtheorem">
<!--l. 539--><p class="noindent" ><span class="head">
<a 
 id="x546-523014r5"></a>
<tspan font-family="cmssbx" font-size="10">Theorem 61.6.5 </tspan><tspan font-family="cmss" font-size="10">(Yoneda lemma)</tspan><br 
class="newline" /> </span><a 
 id="x546-523015"></a> Let <tspan font-family="cmsy" font-size="10">ğ’œ </tspan>be a category, pick <tspan font-family="cmmi" font-size="10">A </tspan><tspan font-family="cmsy" font-size="10">âˆˆğ’œ</tspan>, and let <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub> be the
contravariant Yoneda functor. Let <tspan font-family="cmmi" font-size="10">X </tspan>: <tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmr" font-size="8">op</tspan> <tspan font-family="cmsy" font-size="10">â†’</tspan><tspan font-family="cmss" font-size="10">Set</tspan> be a contravariant functor. Then the
map
                                                                                
                                                                                
</p>
<div class="math-display" >
<img 
src="Na3045x.png" alt="(                                          )
{                                HA        }
(Natural  transformations  ğ’œop      Î±   Set ) â†’  X (A)
                                 X
" class="math-display"  /></div>
<!--l. 548--><p class="noindent" >defined by <tspan font-family="cmmi" font-size="10">Î±</tspan><img 
src="Na3046x.png" alt="â†¦â†’"  class="mapsto"  /><tspan font-family="cmmi" font-size="10">Î±</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>(id<sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>) <tspan font-family="cmsy" font-size="10">âˆˆ </tspan><tspan font-family="cmmi" font-size="10">X</tspan>(<tspan font-family="cmmi" font-size="10">A</tspan>) is an isomorphism of <tspan font-family="cmss" font-size="10">Set</tspan> (i.e.Â a bijection). Moreover, if
we view both sides of the equality as functors
</p>
<div class="math-display" >
<img 
src="Na3047x.png" alt="  op     op
ğ’œ   Ã— [ğ’œ  ,Set] â†’ Set
" class="math-display"  /></div>
<!--l. 552--><p class="noindent" >then this isomorphism is natural.
</p>
  </div>
<!--l. 553--><p class="indent" >  </p></div>
<!--l. 555--><p class="indent" >  This might be startling at first sight. Hereâ€™s an unsatisfying explanation why this might not
be too crazy: in category theory, a rule of thumb is that â€œtwo objects of the same type that are
built naturally are probably the sameâ€. You can see this theme when we defined functors and
natural transformations, and even just compositions. Now to look at the set of natural
transformations, we took a pair of elements <tspan font-family="cmmi" font-size="10">A </tspan><tspan font-family="cmsy" font-size="10">âˆˆğ’œ </tspan>and <tspan font-family="cmmi" font-size="10">X </tspan><tspan font-family="cmsy" font-size="10">âˆˆ </tspan>[<tspan font-family="cmsy" font-size="10">ğ’œ</tspan><tspan font-family="cmr" font-size="8">op</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmss" font-size="10">Set</tspan>] and constructed a <tspan font-family="cmti" font-size="10">set </tspan>of
natural transformations. Is there another way we can get a set from these two pieces of
information? Yes: just look at <tspan font-family="cmmi" font-size="10">X</tspan>(<tspan font-family="cmmi" font-size="10">A</tspan>). The Yoneda lemma is telling us that our heuristic still
holds true here.
</p><!--l. 568--><p class="indent" >  Some consequences of the Yoneda lemma are recorded in <span class="cite">[<tspan font-family="cmbx" font-size="10">?</tspan>]</span>. Since this chapter is
already a bit too long, Iâ€™ll just write down the statements, and refer you to <span class="cite">[<tspan font-family="cmbx" font-size="10">?</tspan>]</span> for the
proofs.
</p><!--l. 573--><p class="indent" >
     </p><dl class="enumerate"><dt class="enumerate">
   1. </dt><dd 
class="enumerate">As we mentioned before, <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmsy" font-size="8">âˆ™</tspan></sup> provides a functor
                                                                                
                                                                                
<div class="math-display" >
<img 
src="Na3048x.png" alt="ğ’œ â†’  [ğ’œop, Set].
" class="math-display"  /></div>
     <!--l. 575--><p class="noindent" >It turns out this functor is in fact <tspan font-family="cmti" font-size="10">fully faithful</tspan>; it quite literally embeds the category
     <tspan font-family="cmsy" font-size="10">ğ’œ </tspan>into the functor category on the right (much like Cayleyâ€™s theorem embeds every
     group into a permutation group).
     </p></dd><dt class="enumerate">
   2. </dt><dd 
class="enumerate">If <tspan font-family="cmmi" font-size="10">X,Y </tspan><tspan font-family="cmsy" font-size="10">âˆˆğ’œ </tspan>then
<div class="math-display" >
<img 
src="Na3049x.png" alt="H   âˆ¼= H   â‡ â‡’  X  âˆ¼= Y  â‡â‡’   HX  âˆ¼= HY .
 X     Y
" class="math-display"  /></div>
     <!--l. 581--><p class="noindent" >To see why this is expected, consider <tspan font-family="cmsy" font-size="10">ğ’œ </tspan>= <tspan font-family="cmss" font-size="10">Grp</tspan> for concreteness. Suppose <tspan font-family="cmmi" font-size="10">A</tspan>, <tspan font-family="cmmi" font-size="10">X</tspan>, <tspan font-family="cmmi" font-size="10">Y </tspan>are
     groups such that <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">X</tspan></sub>(<tspan font-family="cmmi" font-size="10">A</tspan>)<img 
src="Na3050x.png" alt="âˆ¼="  class="cong"  /><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">Y</tspan> </sub>(<tspan font-family="cmmi" font-size="10">A</tspan>) for all <tspan font-family="cmmi" font-size="10">A</tspan>. For example, </p>
          <ul class="itemize1">
          <li class="itemize">If <tspan font-family="cmmi" font-size="10">A </tspan>= <tspan font-family="msbm" font-size="10">â„¤</tspan>, then <img 
src="Na3051x.png" alt="|X |"  class="left" align="middle" /> = <img 
src="Na3052x.png" alt="|Y |"  class="left" align="middle" />.
          </li>
          <li class="itemize">If <tspan font-family="cmmi" font-size="10">A </tspan>= <tspan font-family="msbm" font-size="10">â„¤</tspan><tspan font-family="cmmi" font-size="10">âˆ•</tspan>2<tspan font-family="msbm" font-size="10">â„¤</tspan>, then <tspan font-family="cmmi" font-size="10">X </tspan>and <tspan font-family="cmmi" font-size="10">Y </tspan>have the same number of elements of order 2.
          </li>
          <li class="itemize">â€¦</li></ul>
     <!--l. 589--><p class="noindent" >Each <tspan font-family="cmmi" font-size="10">A </tspan>gives us some information on how <tspan font-family="cmmi" font-size="10">X </tspan>and <tspan font-family="cmmi" font-size="10">Y </tspan>are similar, but the whole natural
     isomorphism is strong enough to imply <tspan font-family="cmmi" font-size="10">X</tspan><img 
src="Na3053x.png" alt="âˆ¼="  class="cong"  /><tspan font-family="cmmi" font-size="10">Y </tspan>.
     </p></dd><dt class="enumerate">
   3. </dt><dd 
class="enumerate">Consider the functor <tspan font-family="cmmi" font-size="10">U </tspan>: <tspan font-family="cmss" font-size="10">Grp</tspan> <tspan font-family="cmsy" font-size="10">â†’</tspan><tspan font-family="cmss" font-size="10">Set</tspan>. It can be represented by <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="msbm" font-size="10">â„¤</tspan></sup>, in the sense
     that
                                                                                
                                                                                
<div class="math-display" >
<img 
src="Na3054x.png" alt="HomGrp (â„¤,G ) âˆ¼= U (G)    by     Ï• â†¦â†’  Ï•(1).
" class="math-display"  /></div>
     <!--l. 596--><p class="noindent" >That is, elements of <tspan font-family="cmmi" font-size="10">G </tspan>are in bijection with maps <tspan font-family="msbm" font-size="10">â„¤ </tspan><tspan font-family="cmsy" font-size="10">â†’ </tspan><tspan font-family="cmmi" font-size="10">G</tspan>, determined by the image of +1
     (or <tspan font-family="cmsy" font-size="10">âˆ’</tspan>1 if you prefer). So a representation of <tspan font-family="cmmi" font-size="10">U </tspan>was determined by looking at <tspan font-family="msbm" font-size="10">â„¤ </tspan>and
     picking +1 <tspan font-family="cmsy" font-size="10">âˆˆ </tspan><tspan font-family="cmmi" font-size="10">U</tspan>(<tspan font-family="msbm" font-size="10">â„¤</tspan>).
     </p><!--l. 600--><p class="noindent" >The generalization of this is a follows: let <tspan font-family="cmsy" font-size="10">ğ’œ </tspan>be a category and <tspan font-family="cmmi" font-size="10">X </tspan>: <tspan font-family="cmsy" font-size="10">ğ’œâ†’</tspan><tspan font-family="cmss" font-size="10">Set</tspan> a covariant
     functor. Then a representation <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmmi" font-size="8">A</tspan></sup><img 
src="Na3055x.png" alt="âˆ¼
="  class="cong"  /><tspan font-family="cmmi" font-size="10">X </tspan>consists of an object <tspan font-family="cmmi" font-size="10">A </tspan><tspan font-family="cmsy" font-size="10">âˆˆğ’œ </tspan>and an
     element <tspan font-family="cmmi" font-size="10">u </tspan><tspan font-family="cmsy" font-size="10">âˆˆ </tspan><tspan font-family="cmmi" font-size="10">X</tspan>(<tspan font-family="cmmi" font-size="10">A</tspan>) satisfying a certain condition. You can read this off the
     condition<span class="footnote-mark"><a 
href="Na542.htm#fn1x70"><sup class="textsuperscript">1</sup></a></span>    <a 
 id="x546-523019f1"></a><span class="footnote-mark"><a 
 id="fn1x70"><sup class="textsuperscript">1 </sup></a></span><tspan font-family="cmr" font-size="9">Just for completeness, the condition is: For all </tspan><tspan font-family="cmmi" font-size="9">A</tspan><tspan font-family="cmsy" font-size="9">â€²âˆˆğ’œ</tspan><tspan font-family="cmr" font-size="9">and </tspan><tspan font-family="cmmi" font-size="9">x </tspan><tspan font-family="cmsy" font-size="9">âˆˆ</tspan><tspan font-family="cmmi" font-size="9">X</tspan><tspan font-family="cmr" font-size="9">(</tspan><tspan font-family="cmmi" font-size="9">A</tspan><tspan font-family="cmsy" font-size="9">â€²</tspan><tspan font-family="cmr" font-size="9">), thereâ€™s a unique </tspan><tspan font-family="cmmi" font-size="9">f </tspan><tspan font-family="cmr" font-size="9">: </tspan><tspan font-family="cmmi" font-size="9">A </tspan><tspan font-family="cmsy" font-size="9">â†’</tspan><tspan font-family="cmmi" font-size="9">A</tspan><tspan font-family="cmsy" font-size="9">â€²</tspan><tspan font-family="cmr" font-size="9">with</tspan>
      <tspan font-family="cmr" font-size="9">(</tspan><tspan font-family="cmmi" font-size="9">Xf</tspan><tspan font-family="cmr" font-size="9">)(</tspan><tspan font-family="cmmi" font-size="9">u</tspan><tspan font-family="cmr" font-size="9">) = </tspan><tspan font-family="cmmi" font-size="9">x</tspan><tspan font-family="cmr" font-size="9">.</tspan> 
     if you know what the inverse map is in <tspan font-family="cmbx" font-size="10">??</tspan>Â . In the above situation, <tspan font-family="cmmi" font-size="10">X </tspan>= <tspan font-family="cmmi" font-size="10">U</tspan>, <tspan font-family="cmmi" font-size="10">A </tspan>= <tspan font-family="msbm" font-size="10">â„¤ </tspan>and
     <tspan font-family="cmmi" font-size="10">u </tspan>= <tspan font-family="cmsy" font-size="10">Â±</tspan>1.</p></dd></dl>
                                                                                
                                                                                
  <!--l. 611--><div class="crosslinks"><p class="noindent">[<a 
href="Nase417.htm" >next</a>] [<a 
href="Nase389.htm" >prev</a>] [<a 
href="Nase389.htm#tailNase389.htm" >prev-tail</a>] [<a 
href="Nase390.htm" >front</a>] [<a 
href="Nach69.htm#Nach70.htm" >up</a>] </p></div>
<!--l. 611--><p class="indent" >  <a 
 id="tailNase390.htm"></a> </p> 
</body> 
</html>