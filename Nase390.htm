<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>(Optional) The Yoneda lemma</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="Napkin.css" /> 
<meta name="src" content="Napkin.tex" /> 
</head><body 
>
  <!--l. 495--><div class="crosslinks"><p class="noindent">[<a 
href="Nase417.htm" >next</a>] [<a 
href="Nase389.htm" >prev</a>] [<a 
href="Nase389.htm#tailNase389.htm" >prev-tail</a>] [<a 
href="Nase366.htm#tailNase390.htm">tail</a>] [<a 
href="Nach69.htm#Nach70.htm" >up</a>] </p></div>
  <h3 class="sectionHead"><span class="titlemark">61.6</span>  <a 
 id="x546-52300061.6"></a>(Optional) The Yoneda lemma</h3>
<!--l. 496--><p class="noindent" >Now that I have natural transformations, I can define: <a 
 id="x546-523001r1590"></a>
</p>
  <div class="newtheorem">
<!--l. 498--><p class="noindent" ><span class="head">
<a 
 id="x546-523002r1"></a>
<tspan font-family="cmbx" font-size="10">Definition 61.6.1.</tspan>  </span><a 
 id="x546-523003"></a>The <tspan font-family="cmbx" font-size="10">functor category</tspan> of two categories <tspan font-family="cmsy" font-size="10">𝒜 </tspan>and <tspan font-family="cmsy" font-size="10">ℬ</tspan>, denoted [<tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmsy" font-size="10">ℬ</tspan>], is
defined as follows: </p>
     <ul class="itemize1">
     <li class="itemize">The objects of [<tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmsy" font-size="10">ℬ</tspan>] are (covariant) functors <tspan font-family="cmmi" font-size="10">F </tspan>: <tspan font-family="cmsy" font-size="10">𝒜→ℬ</tspan>, and
     </li>
     <li class="itemize">The morphisms are natural transformations <tspan font-family="cmmi" font-size="10">α </tspan>: <tspan font-family="cmmi" font-size="10">F </tspan><tspan font-family="cmsy" font-size="10">→ </tspan><tspan font-family="cmmi" font-size="10">G</tspan>.</li></ul>
  </div>
<!--l. 504--><p class="indent" >
</p>
<div class="mdframed" id="mdframed-1054">
<a 
 id="x546-523004r1591"></a>
<div class="newtheorem">
<!--l. 506--><p class="noindent" ><span class="head">
<a 
 id="x546-523005r2"></a>
<tspan font-family="cmbx" font-size="10">Question 61.6.2.</tspan>  </span><a 
 id="x546-523006"></a><tspan font-family="cmr" font-size="10">When are two objects in the functor category isomorphic?</tspan></p>
  </div>
<!--l. 507--><p class="indent" >  </p></div>
<!--l. 509--><p class="indent" >  With this, I can make good on the last example I mentioned at the beginning:</p>
<div class="mdframed" id="mdframed-1055">
<a 
 id="x546-523007r1592"></a>
<div class="newtheorem">
<!--l. 511--><p class="noindent" ><span class="head">
<a 
 id="x546-523008r3"></a>
<tspan font-family="cmbx" font-size="10">Exercise 61.6.3.</tspan>  </span><a 
 id="x546-523009"></a><tspan font-family="cmr" font-size="10">Construct the following functors:</tspan> </p>
                                                                                
                                                                                
     <ul class="itemize1">
     <li class="itemize"><tspan font-family="cmsy" font-size="10">𝒜→ </tspan><tspan font-family="cmr" font-size="10">[</tspan><tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmr" font-size="7">op</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmss" font-size="10">Set</tspan><tspan font-family="cmr" font-size="10">] by </tspan><tspan font-family="cmmi" font-size="10">A</tspan><img 
src="Na3041x.png" alt="↦→"  class="mapsto"  /><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="7">A</tspan></sub><tspan font-family="cmr" font-size="10">, which we call </tspan><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmsy" font-size="7">∙</tspan></sub><tspan font-family="cmr" font-size="10">.</tspan>
     </li>
     <li class="itemize"><tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmr" font-size="7">op</tspan> <tspan font-family="cmsy" font-size="10">→ </tspan><tspan font-family="cmr" font-size="10">[</tspan><tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmss" font-size="10">Set</tspan><tspan font-family="cmr" font-size="10">] by </tspan><tspan font-family="cmmi" font-size="10">A</tspan><img 
src="Na3042x.png" alt="↦→"  class="mapsto"  /><tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmmi" font-size="7">A</tspan></sup><tspan font-family="cmr" font-size="10">, which we call </tspan><tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmsy" font-size="7">∙</tspan></sup><tspan font-family="cmr" font-size="10">.</tspan></li></ul>
</p>
  </div>
<!--l. 516--><p class="indent" >  </p></div>
<!--l. 517--><p class="indent" >  Notice that we have opposite categories either way; even if you like <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmmi" font-size="8">A</tspan></sup> because it
is covariant, the map <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmsy" font-size="8">∙</tspan></sup> is contravariant. So for what follows, we’ll prefer to use
<tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmsy" font-size="8">∙</tspan></sub>.
</p><!--l. 521--><p class="indent" >  The main observation now is that given a category <tspan font-family="cmsy" font-size="10">𝒜</tspan>, <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmsy" font-size="8">∙</tspan></sub> provides some <tspan font-family="cmti" font-size="10">special </tspan>functors
<tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmr" font-size="8">op</tspan> <tspan font-family="cmsy" font-size="10">→</tspan><tspan font-family="cmss" font-size="10">Set</tspan> which are already “built” in to the category <tspan font-family="cmmi" font-size="10">A</tspan>. In light of this, we define:
<a 
 id="x546-523010r1593"></a>
</p>
  <div class="newtheorem">
<!--l. 525--><p class="noindent" ><span class="head">
<a 
 id="x546-523011r4"></a>
<tspan font-family="cmbx" font-size="10">Definition 61.6.4.</tspan>  </span><a 
 id="x546-523012"></a>A <tspan font-family="cmbx" font-size="10">presheaf</tspan> <tspan font-family="cmmi" font-size="10">X </tspan>is just a contravariant functor <tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmr" font-size="8">op</tspan> <tspan font-family="cmsy" font-size="10">→</tspan><tspan font-family="cmss" font-size="10">Set</tspan>. It is called
<tspan font-family="cmbx" font-size="10">representable</tspan> if <tspan font-family="cmmi" font-size="10">X</tspan><img 
src="Na3043x.png" alt="∼
="  class="cong"  /><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub> for some <tspan font-family="cmmi" font-size="10">A</tspan>.
</p>
  </div>
<!--l. 527--><p class="indent" >
In other words, when we think about representable, the question we’re asking is:
     </p><blockquote class="quote">
     <!--l. 531--><p class="noindent" ><tspan font-family="cmti" font-size="10">What kind of presheaves are already “built in” to the category </tspan><tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmti" font-size="10">?</tspan></p></blockquote>
<!--l. 533--><p class="noindent" >One way to get at this question is: given a presheaf <tspan font-family="cmmi" font-size="10">X </tspan>and a particular <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>, we can look at the
<tspan font-family="cmti" font-size="10">set </tspan>of natural transformations <tspan font-family="cmmi" font-size="10">α </tspan>: <tspan font-family="cmmi" font-size="10">X</tspan> <img 
src="Na3044x.png" alt="= ⇒"  class="Longrightarrow"  /> <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>, and see if we can learn anything about it. In
fact, this set can be written explicitly:</p>
<div class="mdframed" id="mdframed-1056">
<a 
 id="x546-523013r1594"></a>
<div class="newtheorem">
<!--l. 539--><p class="noindent" ><span class="head">
<a 
 id="x546-523014r5"></a>
<tspan font-family="cmssbx" font-size="10">Theorem 61.6.5 </tspan><tspan font-family="cmss" font-size="10">(Yoneda lemma)</tspan><br 
class="newline" /> </span><a 
 id="x546-523015"></a> Let <tspan font-family="cmsy" font-size="10">𝒜 </tspan>be a category, pick <tspan font-family="cmmi" font-size="10">A </tspan><tspan font-family="cmsy" font-size="10">∈𝒜</tspan>, and let <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub> be the
contravariant Yoneda functor. Let <tspan font-family="cmmi" font-size="10">X </tspan>: <tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmr" font-size="8">op</tspan> <tspan font-family="cmsy" font-size="10">→</tspan><tspan font-family="cmss" font-size="10">Set</tspan> be a contravariant functor. Then the
map
                                                                                
                                                                                
</p>
<div class="math-display" >
<img 
src="Na3045x.png" alt="(                                          )
{                                HA        }
(Natural  transformations  𝒜op      α   Set ) →  X (A)
                                 X
" class="math-display"  /></div>
<!--l. 548--><p class="noindent" >defined by <tspan font-family="cmmi" font-size="10">α</tspan><img 
src="Na3046x.png" alt="↦→"  class="mapsto"  /><tspan font-family="cmmi" font-size="10">α</tspan><sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>(id<sub><tspan font-family="cmmi" font-size="8">A</tspan></sub>) <tspan font-family="cmsy" font-size="10">∈ </tspan><tspan font-family="cmmi" font-size="10">X</tspan>(<tspan font-family="cmmi" font-size="10">A</tspan>) is an isomorphism of <tspan font-family="cmss" font-size="10">Set</tspan> (i.e. a bijection). Moreover, if
we view both sides of the equality as functors
</p>
<div class="math-display" >
<img 
src="Na3047x.png" alt="  op     op
𝒜   × [𝒜  ,Set] → Set
" class="math-display"  /></div>
<!--l. 552--><p class="noindent" >then this isomorphism is natural.
</p>
  </div>
<!--l. 553--><p class="indent" >  </p></div>
<!--l. 555--><p class="indent" >  This might be startling at first sight. Here’s an unsatisfying explanation why this might not
be too crazy: in category theory, a rule of thumb is that “two objects of the same type that are
built naturally are probably the same”. You can see this theme when we defined functors and
natural transformations, and even just compositions. Now to look at the set of natural
transformations, we took a pair of elements <tspan font-family="cmmi" font-size="10">A </tspan><tspan font-family="cmsy" font-size="10">∈𝒜 </tspan>and <tspan font-family="cmmi" font-size="10">X </tspan><tspan font-family="cmsy" font-size="10">∈ </tspan>[<tspan font-family="cmsy" font-size="10">𝒜</tspan><tspan font-family="cmr" font-size="8">op</tspan><tspan font-family="cmmi" font-size="10">,</tspan><tspan font-family="cmss" font-size="10">Set</tspan>] and constructed a <tspan font-family="cmti" font-size="10">set </tspan>of
natural transformations. Is there another way we can get a set from these two pieces of
information? Yes: just look at <tspan font-family="cmmi" font-size="10">X</tspan>(<tspan font-family="cmmi" font-size="10">A</tspan>). The Yoneda lemma is telling us that our heuristic still
holds true here.
</p><!--l. 568--><p class="indent" >  Some consequences of the Yoneda lemma are recorded in <span class="cite">[<tspan font-family="cmbx" font-size="10">?</tspan>]</span>. Since this chapter is
already a bit too long, I’ll just write down the statements, and refer you to <span class="cite">[<tspan font-family="cmbx" font-size="10">?</tspan>]</span> for the
proofs.
</p><!--l. 573--><p class="indent" >
     </p><dl class="enumerate"><dt class="enumerate">
   1. </dt><dd 
class="enumerate">As we mentioned before, <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmsy" font-size="8">∙</tspan></sup> provides a functor
                                                                                
                                                                                
<div class="math-display" >
<img 
src="Na3048x.png" alt="𝒜 →  [𝒜op, Set].
" class="math-display"  /></div>
     <!--l. 575--><p class="noindent" >It turns out this functor is in fact <tspan font-family="cmti" font-size="10">fully faithful</tspan>; it quite literally embeds the category
     <tspan font-family="cmsy" font-size="10">𝒜 </tspan>into the functor category on the right (much like Cayley’s theorem embeds every
     group into a permutation group).
     </p></dd><dt class="enumerate">
   2. </dt><dd 
class="enumerate">If <tspan font-family="cmmi" font-size="10">X,Y </tspan><tspan font-family="cmsy" font-size="10">∈𝒜 </tspan>then
<div class="math-display" >
<img 
src="Na3049x.png" alt="H   ∼= H   ⇐ ⇒  X  ∼= Y  ⇐⇒   HX  ∼= HY .
 X     Y
" class="math-display"  /></div>
     <!--l. 581--><p class="noindent" >To see why this is expected, consider <tspan font-family="cmsy" font-size="10">𝒜 </tspan>= <tspan font-family="cmss" font-size="10">Grp</tspan> for concreteness. Suppose <tspan font-family="cmmi" font-size="10">A</tspan>, <tspan font-family="cmmi" font-size="10">X</tspan>, <tspan font-family="cmmi" font-size="10">Y </tspan>are
     groups such that <tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">X</tspan></sub>(<tspan font-family="cmmi" font-size="10">A</tspan>)<img 
src="Na3050x.png" alt="∼="  class="cong"  /><tspan font-family="cmmi" font-size="10">H</tspan><sub><tspan font-family="cmmi" font-size="8">Y</tspan> </sub>(<tspan font-family="cmmi" font-size="10">A</tspan>) for all <tspan font-family="cmmi" font-size="10">A</tspan>. For example, </p>
          <ul class="itemize1">
          <li class="itemize">If <tspan font-family="cmmi" font-size="10">A </tspan>= <tspan font-family="msbm" font-size="10">ℤ</tspan>, then <img 
src="Na3051x.png" alt="|X |"  class="left" align="middle" /> = <img 
src="Na3052x.png" alt="|Y |"  class="left" align="middle" />.
          </li>
          <li class="itemize">If <tspan font-family="cmmi" font-size="10">A </tspan>= <tspan font-family="msbm" font-size="10">ℤ</tspan><tspan font-family="cmmi" font-size="10">∕</tspan>2<tspan font-family="msbm" font-size="10">ℤ</tspan>, then <tspan font-family="cmmi" font-size="10">X </tspan>and <tspan font-family="cmmi" font-size="10">Y </tspan>have the same number of elements of order 2.
          </li>
          <li class="itemize">…</li></ul>
     <!--l. 589--><p class="noindent" >Each <tspan font-family="cmmi" font-size="10">A </tspan>gives us some information on how <tspan font-family="cmmi" font-size="10">X </tspan>and <tspan font-family="cmmi" font-size="10">Y </tspan>are similar, but the whole natural
     isomorphism is strong enough to imply <tspan font-family="cmmi" font-size="10">X</tspan><img 
src="Na3053x.png" alt="∼="  class="cong"  /><tspan font-family="cmmi" font-size="10">Y </tspan>.
     </p></dd><dt class="enumerate">
   3. </dt><dd 
class="enumerate">Consider the functor <tspan font-family="cmmi" font-size="10">U </tspan>: <tspan font-family="cmss" font-size="10">Grp</tspan> <tspan font-family="cmsy" font-size="10">→</tspan><tspan font-family="cmss" font-size="10">Set</tspan>. It can be represented by <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="msbm" font-size="10">ℤ</tspan></sup>, in the sense
     that
                                                                                
                                                                                
<div class="math-display" >
<img 
src="Na3054x.png" alt="HomGrp (ℤ,G ) ∼= U (G)    by     ϕ ↦→  ϕ(1).
" class="math-display"  /></div>
     <!--l. 596--><p class="noindent" >That is, elements of <tspan font-family="cmmi" font-size="10">G </tspan>are in bijection with maps <tspan font-family="msbm" font-size="10">ℤ </tspan><tspan font-family="cmsy" font-size="10">→ </tspan><tspan font-family="cmmi" font-size="10">G</tspan>, determined by the image of +1
     (or <tspan font-family="cmsy" font-size="10">−</tspan>1 if you prefer). So a representation of <tspan font-family="cmmi" font-size="10">U </tspan>was determined by looking at <tspan font-family="msbm" font-size="10">ℤ </tspan>and
     picking +1 <tspan font-family="cmsy" font-size="10">∈ </tspan><tspan font-family="cmmi" font-size="10">U</tspan>(<tspan font-family="msbm" font-size="10">ℤ</tspan>).
     </p><!--l. 600--><p class="noindent" >The generalization of this is a follows: let <tspan font-family="cmsy" font-size="10">𝒜 </tspan>be a category and <tspan font-family="cmmi" font-size="10">X </tspan>: <tspan font-family="cmsy" font-size="10">𝒜→</tspan><tspan font-family="cmss" font-size="10">Set</tspan> a covariant
     functor. Then a representation <tspan font-family="cmmi" font-size="10">H</tspan><sup><tspan font-family="cmmi" font-size="8">A</tspan></sup><img 
src="Na3055x.png" alt="∼
="  class="cong"  /><tspan font-family="cmmi" font-size="10">X </tspan>consists of an object <tspan font-family="cmmi" font-size="10">A </tspan><tspan font-family="cmsy" font-size="10">∈𝒜 </tspan>and an
     element <tspan font-family="cmmi" font-size="10">u </tspan><tspan font-family="cmsy" font-size="10">∈ </tspan><tspan font-family="cmmi" font-size="10">X</tspan>(<tspan font-family="cmmi" font-size="10">A</tspan>) satisfying a certain condition. You can read this off the
     condition<span class="footnote-mark"><a 
href="Na542.htm#fn1x70"><sup class="textsuperscript">1</sup></a></span>    <a 
 id="x546-523019f1"></a><span class="footnote-mark"><a 
 id="fn1x70"><sup class="textsuperscript">1 </sup></a></span><tspan font-family="cmr" font-size="9">Just for completeness, the condition is: For all </tspan><tspan font-family="cmmi" font-size="9">A</tspan><tspan font-family="cmsy" font-size="9">′∈𝒜</tspan><tspan font-family="cmr" font-size="9">and </tspan><tspan font-family="cmmi" font-size="9">x </tspan><tspan font-family="cmsy" font-size="9">∈</tspan><tspan font-family="cmmi" font-size="9">X</tspan><tspan font-family="cmr" font-size="9">(</tspan><tspan font-family="cmmi" font-size="9">A</tspan><tspan font-family="cmsy" font-size="9">′</tspan><tspan font-family="cmr" font-size="9">), there’s a unique </tspan><tspan font-family="cmmi" font-size="9">f </tspan><tspan font-family="cmr" font-size="9">: </tspan><tspan font-family="cmmi" font-size="9">A </tspan><tspan font-family="cmsy" font-size="9">→</tspan><tspan font-family="cmmi" font-size="9">A</tspan><tspan font-family="cmsy" font-size="9">′</tspan><tspan font-family="cmr" font-size="9">with</tspan>
      <tspan font-family="cmr" font-size="9">(</tspan><tspan font-family="cmmi" font-size="9">Xf</tspan><tspan font-family="cmr" font-size="9">)(</tspan><tspan font-family="cmmi" font-size="9">u</tspan><tspan font-family="cmr" font-size="9">) = </tspan><tspan font-family="cmmi" font-size="9">x</tspan><tspan font-family="cmr" font-size="9">.</tspan> 
     if you know what the inverse map is in <tspan font-family="cmbx" font-size="10">??</tspan> . In the above situation, <tspan font-family="cmmi" font-size="10">X </tspan>= <tspan font-family="cmmi" font-size="10">U</tspan>, <tspan font-family="cmmi" font-size="10">A </tspan>= <tspan font-family="msbm" font-size="10">ℤ </tspan>and
     <tspan font-family="cmmi" font-size="10">u </tspan>= <tspan font-family="cmsy" font-size="10">±</tspan>1.</p></dd></dl>
                                                                                
                                                                                
  <!--l. 611--><div class="crosslinks"><p class="noindent">[<a 
href="Nase417.htm" >next</a>] [<a 
href="Nase389.htm" >prev</a>] [<a 
href="Nase389.htm#tailNase389.htm" >prev-tail</a>] [<a 
href="Nase390.htm" >front</a>] [<a 
href="Nach69.htm#Nach70.htm" >up</a>] </p></div>
<!--l. 611--><p class="indent" >  <a 
 id="tailNase390.htm"></a> </p> 
</body> 
</html>